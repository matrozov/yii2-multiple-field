# Валидация

## Обработка ошибок

Отличительной особенностью данного виджета является прозрачная и полнофункциональная система обработки и отображения
ошибок полей формы. Используя встроенный набор валидаторов можно реализовать и вернуть на форму ошибки для конкретного
поля в конкретном блоке. Т.е., например, если ошибку вызвало некое поле в третьем по счету блоке, то именно под ним и будет
выведена ошибка при возврате на форму. Список валидаторов избыточен и для реализации базовой валидации достаточно использовать два из
них: [KeyArrayValidator](validators.md#user-content-keyarrayvalidator) и
[KeyModelValidator](validators.md#user-content-keymodelvalidator). Отличием между ними является только формат описания
правил валидации.

---

Базовый класс валидатора реализует механизм, позволяющий указать, какой формат ошибки будет использоваться при формировании имени поля,
в котором произошла ошибка. Допустимы два варианта значения:

**Validator::ERROR_FORMAT_URL** - формат используемый по умолчанию. Совместим с MultipleField для визуализации ошибок во View.
Вложенные поля с ошибками формируются в виде элементов в квадратных скобках:
```
my_field[0][title]
```
**Validator::ERROR_FORMAT_DOT** - формат формирования поля, в котором используется точка "." в виде разделителя:
```
my_field.0.title
```
Обычно применяется для визуализации ошибок на уровне API.

---

Формат ошибки можно задать как глобально:
```php
Validator::$globalErrorFormat = Validator::ERROR_FORMAT_DOT;
```
или локально, на уровне любого валидатора, например:
```php
[['my-field'], ArrayValidator::class, 'rules' => [...], 'errorFormat' => Validator::ERROR_FORMAT_DOT],
```

## Валидаторы

Решение предлагает несколько валидаторов в зависимости от того, что именно необходимо валидировать:

### Валидация вложенной модели:

```json
{
  "nested-model": {
    "nested-field": "nested-field-model",
    ...
  }
}
```

* [ArrayValidator](validators.md#user-content-arrayvalidator)
* [ModelValidator](validators.md#user-content-modelvalidator)  

### Валидация ключей вложенного массива

```json
{
  "nested-array": [
    "key1": ...,
    "key2": ...,
    ...
  ]
}
```

* [KeyValidator](validators.md#user-content-keyvalidator)

### Валидация простых значений вложенного массива

```json
{
  "nested-array": [
    "value1",
    "value2"
  ]
}
```

* [KeyValueValidator](validators.md#user-content-keyvaluevalidator)

### Валидация вложенного массива моделей

```json
{
  "nested-array-model": [
    {
      "nested-model-field": "nested-model-field-value",
      ...
    },
    ...
  ]
}
```

* [KeyArrayValidator](validators.md#user-content-keyarrayvalidator)
* [KeyModelValidator](validators.md#user-content-keymodelvalidator)

## ArrayValidator

Валидатор полей вложенного ассоциативного массива в указанное поле.

```php
'my-field' => [ // Ассоциативный массив
    'field1' => 'value1',
    'field1' => 'value2',
    ...
]
```

Конфигурация валидатора выглядит следующим образом:

```php
[['my-field'], ArrayValidator::class, 'rules' => [
    [['field1', 'field2'], 'required'],
    [['field1'], 'string', 'max' => 255],
    [['field2'], 'integer'],
    ...
]],
```

Где для каждого поля мы можем указать один или более валидаторов.

## ModelValidator

Валидатор полей вложенного ассоциативного массива в указанное поле через указанную модель.
Является, по сути, интерпретацией ArrayValidator, где правила валидации описаны отдельной моделью.

```php
'my-field' => [ // Ассоциативный массив или экземпляры модели
    'field1' => 'value1',
    'field2' => 'value2',
    ...
]
```

Конфигурация валидатора выглядит следующим образом:

```php
[['my-field'], ModelValidator::class, 'model' => MyFieldModel::class, 'scenario' => MyFieldModel::SCENARIO_MY],
```

При этом в указанной модели описаны rules вида:

```php
[['field1', 'field2'], 'required'],
[['field1'], 'string', 'max' => 255],
[['field2'], 'integer'],
...
```

Стоит отметить, что после успешной валидации валидатор преобразует значение исходного поля в экземпляр указанной модели.

## KeyValidator

Валидатор ключей переданного ассоциативного массива без валидации его значений. 

```php
'my-field' => [ // Ассоциативный массив
    'key1' => ...,
    'key2' => ...,
    ...
];
```

Конфигурация валидатора выглядит следующим образом:

```php
[['my-field'], KeyValidator::class, 'keyRules' => [
    ['integer', 'max' => 100],
    ...
], 'keyIsIndexed' => true, 'min' => 2, 'max' => 5],
```

Правила валидации записываются аналогично виду стандартного
[each](https://www.yiiframework.com/doc/api/2.0/yii-validators-eachvalidator)-валидатора с указанием только правил валидации.
Дополнительные параметры позволяют более строго валидировать массив элементов:
**keyIsIndexed** - (по умолчанию = false) проверяет, являются ли переданные ключи последовательными числами начинающимися с 0.
**messageKeyIsIndexed** - задаёт текст сообщения ошибки в случае, если массив не является последовательным.
**min** - указывает на минимальное количество элементов массива.
**messageMin** - задаёт текст сообщения ошибки в случае, если элементов в массиме меньше указанного.
**max** - указывает на максимальное количество элементов массива.
**messageMax** - задаёт текст сообщения ошибки в случае, если элементов в массиме больше указанного.

Все механики валидации ключей доступны и в наследуемых валидаторах: KeyValueValidator, KeyArrayValidator и KeyModelValidator

## KeyValueValidator

Валидатор однотипный полей ассоциативного массива. По сути, это массовый стандартный
[each](https://www.yiiframework.com/doc/api/2.0/yii-validators-eachvalidator)-валидатор, позволяющий указать сразу
несколько правил для валидации. Валидатор является наследником KeyValidator и позволяет, в том числе, валидировать и ключи.

```php
'my-field' => [ // Ассоциативный массив значений
    'key1' => 'value1',
    'key2' => 'value2',
    ...    
];
```

Конфигурация валидатора выглядит следующим образом:

```php
[['my-field'], KeyValueValidator::class, 'keyRules' => [
    ['integer', 'max' => 100],
    ...
], 'rules' => [
    ['string', 'max' => 255],
    ...
]]
```

## KeyArrayValidator

Валидатор массива однотипных ассоциативных массивов. Является, по сути, объединением KeyValidator, для валидации ключей
и ArrayValidator, для валидации массива полей. 

```php
[ // Ассоциативный массив массивов
    'key1' => [ // Ассоциативный массив значений
        'field1' => 'value1',
        'field2' => 'value2',
        ...
    ],
    'key2' => [ // Ассоциативный массив значений
        'field1' => 'value1',
        'field2' => 'value2',
        ...
    ],
    ...    
];
```

Конфигурация валидатора выглядит следующим образом:

```php
[['my-field'], KeyArrayValidator::class, 'keyRules' => [
    ['integer', 'max' => 100],
    ...
], 'rules' => [
    [['field1', 'field2'], 'required'],
    [['field1'], 'string', 'max' => 255],
    [['field2'], 'integer'],
    ...
]]
```

## KeyModelValidator

Валидатор массива однотипных ассоциативных массивов через указанную модель. Как и KeyArrayValidator, KeyModelValidator
является, по сути, объединением KeyValidator, для валидации ключей и ModelValidator, для валидации массива полей через модель.

```php
'my-field' => [ // Ассоциативный массив массивов или экземпляров моделей
    'key1' => [ // Ассоциативный массив или экземпляры модели
        'field1' => 'value1',
        'field2' => 'value2',
        ...
    ],
    'key2' => [ // Ассоциативный массив или экземпляры модели
        'field1' => 'value1',
        'field2' => 'value2',
        ...
    ],
    ...    
];
```

Конфигурация валидатора выглядит следующим образом:

```php
[['my-field'], KeyArrayValidator::class, 'keyRules' => [
    ['integer', 'max' => 100],
    ...
], 'model' => MyFieldModel::class, 'scenario' => MyFieldModel::SCENARIO_MY]]
```

При этом в указанной модели описаны rules вида:

```php
[['field1', 'field2'], 'required'],
[['field1'], 'string', 'max' => 255],
[['field2'], 'integer'],
...
```

Стоит отметить, что после успешной валидации валидатор преобразует значение исходного поля в экземпляр указанной модели.
